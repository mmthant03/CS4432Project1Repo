    
Robert Dutile, Myo Min Thant

Design File:

  In the creation of this extension, we largely followed a process of taking one task at a time, figuring out what we needed to add or change to make it work, performing those alterations, and then moving on to the next. We found that nearly all of the work necessary we could and did perform in the Buffer and BasicBufferMgr files, with the exception of a single toString method we added to the BufferMgr file.
  To make everything work, we had to add metadata and data structures to both files. In Buffer, we added the boolean refBit to represent our reference bit, and the integer bufferIndex so that each buffer could store it's own ID, which was also its location in the bufferpool array.  We added a getter and setter for the refBit, and a getter for the bufferIndex, along side a new constructor that took an integer argument as the initial bufferIndex. The BasicBufferMgr needed a linkedlist that stored the addresses of empty frames, a hashtable that stored the bufferIndex blockNum pairs that were currently in the buffer manager, an int to keep track of where the clock pointer is currently looking in the bufferpool, and another int to store the number of buffers in the pool somewhere convenient. This of course also lead to us adding to the constructor to make sure everything initialized properly.
  As far as functions go, in BasicBufferMgr we adjusted pin and pinNew to integrate our modified replacement and lookup functions, and to trigger the new updateBuff function that keeps the hashtable up to date. We modified findExistingBuffer to make it check the hashtable instead of searching through the bufferpool linearly.  We set up the chooseExistingBuffer function to check the list of empty frames, and if that was empty then to call the new clockReplace helper function, which contains the clock replacement algorithm that we decided upon. Finally, we added a toString, that uses a for loop to call and add together the toStrings of each buffer in the pool, and then returns the result.
  In Buffer, we added functions to get the bufferIndex, refBit, and the number of the block in the buffer, as well as one to set the refBit. We also had to add a toString method that returns a string containing the buffer index, the block toString, and whether or not the buffer is pinned. Finally, we added a toString function to the BufferMgr file that returns the results of calling toString on its BasicBufferMgr.
